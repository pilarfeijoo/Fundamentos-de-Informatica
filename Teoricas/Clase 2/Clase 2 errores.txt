
Una de las palabras reservadas es try, esta nos permite "encapsular" un bloque de código para interceptar e identificar 
excepciones. Si se produce un error dentro de la declaración try-except, se omite una excepción y se ejecuta el bloque de
 código que maneja la excepción.

try:
    # aquí ponemos el código que puede lanzar excepciones
except:
    # entrará aquí en caso que se haya producido una excepción

try:
    print (asdsadsa)
except:
    print("Error de comillas")


En algunos casos, puede ser necesario crear excepciones personalizadas o forzar que ocurra una excepción específica dado un 
contexto. La sentencia raise, se puede indicar el tipo de excepción que deseamos lanzar y el mensaje de que queremos brindarle
 al usuario:

def check_int_type():
  if type(x)  != int:
    raise TypeError("Only integers are allowed") 


Desafio II: Creá una función denominada mitades que tenga como argumento un número e imprima el
 resultado de la división de ese número por 2

Para pensar 🤔: ¿Qué crees que ocurrirá cuando ingresas un 9 como parámetro? ¿Y con un 0?

🧗‍♀️Desafio III: ¿Cómo mejorarías tu función para que sea capaz de manejar el error de la división 
por cero? Reescribí la función incorporando una declaración try-except